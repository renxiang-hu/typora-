### 满二叉树

满二叉树是一种特殊类型的二叉树，它具有以下两个性质：

* 每个非叶子节点上有两个子节点
* 所有叶子节点都在同一层上

换句话说，满二叉树是一棵深度为h的二叉树，其每一层都恰好有2^(h-1)个节点。其中，h表示树的高度，叶子节点即为最底层的节点。

例如，下图所示的树就是一棵深度为3的满二叉树：

```java
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
```

### 完全二叉树

完全二叉树是一种特殊类型的二叉树，它具有以下两个性质：

* 对于深度为k的节点，它的左子树必须填满，右子树要么也填满，要么为空。

* 最后一层上的节点都集中在该层最左边的若干位置上。

换句话说，对于一棵深度为h的完全二叉树，除了最后一层外，其他层的节点数都达到最大值，最后一层的节点都靠左排列。

例如，下图所示的树就是一棵深度为3的完全二叉树：

```java
        1
      /   \
     2     3
    / \   
   4   5 
```

### 二叉搜索树

二叉搜索树（Binary Search Tree，BST）是一种二叉树，其中每个节点的值都大于其左子树中任意节点的值，而小于其右子树中任意节点的值。换句话说，对于BST中的任何节点x，其左子树中的所有节点值都小于x的值，而其右子树中的所有节点值都大于x的值。

例如，下图所示的树就是一棵BST：

```java
        6
      /   \
     3     8
    / \   / \
   2   4 7   9
```

BST具有以下特点：

* 在BST中，任意节点的左子树都比该节点小，右子树都比该节点大，因此对于任何节点，其左子树和右子树也都是一棵BST。
* 对于任意节点x，如果它的左子树不为空，则左子树中最大值为x左子树中的最右节点；如果它的右子树不为空，则右子树中最小值为x右子树中的最左节点。
* 如果BST的左右子树的深度相差太大，就会退化成链表，因此需要考虑平衡BST的实现，如AVL树和红黑树等。

### 平衡二叉搜索树

平衡二叉搜索树（Balanced Binary Search Tree，BBST）是一种二叉搜索树，其中每个节点的左右子树高度差不超过1，也就是说，其左右子树高度大致相等。

### 深度优先遍历

深度优先遍历（Depth-First-Search，DFS）是二叉树和图的常用遍历方式之一，它的核心思想是尽可能深地搜索树的分支。

对于二叉树的深度优先遍历，常见的有三种遍历方式：

1. 前序遍历（Pre-Order Traversal）

前序遍历是指先遍历根节点，然后遍历左子树，最后遍历右子树。

2. 中序遍历（In-Order Traversal）

中序遍历是指先遍历左子树，然后遍历根节点，最后遍历右子树。

3. 后序遍历（Post-Order Traversal）

后序遍历是指先遍历左子树，然后遍历右子树，最后遍历根节点。

### 广度优先遍历

广度优先遍历（Breadth-First-Search，BFS）是二叉树和图的常用遍历方式之一，它的核心思想是逐层遍历树的节点。

对于二叉树的广度优先遍历，一般使用队列来实现。具体实现过程如下：

1. 将根节点加入队列中。
2. 当队列不为空时，重复以下操作：
   1. 弹出队头节点，将其值加入遍历结果列表中。
   2. 如果该节点有左子节点，则将左子节点加入队列中。
   3. 如果该节点有右子节点，则将右子节点加入队列中。